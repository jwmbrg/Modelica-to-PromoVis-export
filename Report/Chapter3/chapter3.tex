\section{General structure}
The internal structure are divided into four explicit phases. 
\subsection{JModelica(Compile)Phase}
The JModelica environment is used to compile the Modelica models to JModelicas JMU representation \cite{jmodelicaorg}\nocite{*}. ProMoVis assumes the systems to be linear and the compiled model needs to be linearised around an operating point. The linearisation is performed at time 0, and it is assumed that the system is stable at the time.\\\\After linearisation a DAE on the following form can be extracted:
\begin{equation}
E*dx = A*x + B*u + F*w + g
\end{equation}
This represenation should be familiar, the x and dx vectors represents the states and outputs of the linearized system. The u vector represents declared inputs. W is algebraic variables, that is all variables in the original model that has no derivative declared. Finally g is a constant bias vector.\\\\The linearisation also outputs some useful information that we later use in the generation of the ProMoVis scenarios:
\begin{itemize}
\item \textit{State names}, corresponding to the declared variable names from the original Modelica file.
\item \textit{Input names}, corresponding to the declared input names from the original Modelica file.
\item \textit{Algebraic names}, corresponding to the declared algebraic variable names from the original Modelica file.
\item \textit{Operating points} for the linear model \textit{dx0},\textit{w0}, \textit{u0} and \textit{x0}. Which is , in later stages, used to provide feedback for the user regarding the validity of the resulting model.
\end{itemize}
From now on we will refer to states and algebraic variables as simply "variables" and whenever a distinction between the two is needed, it will be explicitly declared. 

\subsection{Generation of the internal structure}
When the DAE is obtained, the task is then to extract the relations between the variables from it. The tool collects and stores each of the variables, together with each of the variables that acts as inputs to it. Although it might feel more natural to store a variable together with each of the variables that it affects, this representation was choosen since ProMoVis supports both of the representations but it is straightforward, from the DAE, to solve a variable for all its inputs.\\\newline
This fact is easilly seen with the following example.\\\newline
The DAE for a model with two state variables, two inputs and and two algebraic variables could be described by the following general structure:\\\newline
$
\begin{bmatrix} E_{11} & E_{12} \\ E_{21} & E_{22} \\ E_{31} & E_{32} \\ E_{41} & E_{42} \end{bmatrix} \left[ \begin{array}{c} x0' \\ x1' \end{array} \right]
= \begin{bmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \\ A_{31} & A_{32} \\ A_{41} & A_{42} \end{bmatrix} \left[ \begin{array}{c} x0 \\ x1 \end{array} \right] + \begin{bmatrix} B_{11} & B_{12} \\ B_{21} & B_{22} \\ B_{31} & B_{32} \\ B_{41} & B_{42} \end{bmatrix} \left[ \begin{array}{c} u0 \\ u1 \end{array} \right]+
\begin{bmatrix} F_{11} & F_{12} \\ F_{21} & F_{22} \\ F_{31} & F_{32} \\ F_{41} & F_{42}\end{bmatrix} \left[ \begin{array}{c} w0 \\ w1 \end{array} \right]$\\\newline The task is now, to find which of the rows in the system that should be solved for which variable so that the whole system can be solved. Here a demand is that the DAE may not contain any Algebraic loops. For a more thorough discussion regarding this and the decision of which row to solve for which variable please review Appendix \ref{appA}\\\\After deciding which row that should be solved for which of the variables we build up an intermediate representation of the SFG, used internally in the tool, where we store each of the variables together with all of its input variables. This is best explained with the help of an example, if we assume that we should solve row 1 for x0 the procedure is as follows:\\\\$\begin{array}{rcl} E_{11}*x0*s  +E_{12}*x1*s=A_{11}*x0  +A_{12}*x1 +B_{11}*u0  +B_{12}*u1  +F_{11}*w0  +F_{12}*w1 \end{array}$\\
\\Putting x0 alone on the left-hand side and collecting the coefficients then yields:\\\\$\begin{array}{rcl} (E_{11}*s-A_{11})*x0  =(A_{12}-E_{12}*s)*x1 +B_{11}*u0  +B_{12}*u1 +F_{11}*w0  +F_{12}*w1 \end{array}$\\\\
Finally, solving for x0 yields:\\\\
$\begin{array}{rcl} x0  = \frac{(A_{12}-E_{12}*s)}{(E_{11}*s-A_{11})}*x1 +\frac{B_{11}}{(E_{11}*s-A_{11})}*u0  +\frac{B_{12}}{(E_{11}*s-A_{11})}*u1 ++\frac{F_{11}}{(E_{11}*s-A_{11})}*w0 +\frac{F_{12}}{(E_{11}*s-A_{11})}*w1\end{array}$\\\newline Naturally, only the variables with non-zero coefficients are stored as input variables.\\Roughly, the internal representation looks as the following:\\\newline
\setlength\fboxsep{0pt}
\setlength\fboxrule{0.5pt}
\fbox{\includegraphics[scale=0.8,bb=0 0 97mm 111mm] {Figures/variable_structure.pdf}}\\\newline Here inputs is a dictionary with variable names as keys and the corresponding transfer functions as a values. A transfer function, in the export tool, is using the same convention as in MatLab to represent the numerator and denominator coefficients in two separate arrays.
\subsection{Validation and Transformations}
After extracting the variables, we examine the the derivatives for each of the states to make sure that they are 0, no error is produced if they are not. But a warning is emitted so that the user is aware of the fact that the model they are using probably is invalid. During this phase, additional modifications, provided by the user, should be done. Currently, the only modification supported, is the ability to indicate that some of the variables in the system should be emitted as measured variables in the resulting ProMoVis representation. By default, all input variables are emitted as control variables, while the others are emitted as internal variables.
\subsection{Scenario generation}
When the structure is validated and all optional transformations have been done. The actual generation of the ProMoVis represenation is straightforward. Basically the ProMoVis representation contains two parts. First the descriptive part, a collection of all variables, with their names, graphical layout and additional mathematical properties. The second part, the processmodels, are describing the relations between variables in the system. 
\subsubsection{Graphical Layout}
Even though Modelica supports description of position and graphical representation of models through its annotations interface, these are not necessary for a valid Modelica model. Therefore no effort has been put into trying to extract this type of meta-information. Instead, to make sure that a user of ProMoVis is able to easily access and attach controllers to the generated model the variables are emitted as depicted in the figure below.\\\newline
\setlength\fboxsep{0pt}
\setlength\fboxrule{0.5pt}
\fbox{\includegraphics[scale=0.8,bb=0 0 117mm 154mm] {Figures/layout.pdf}}\\\newline That is, control and measured variables are emitted as the upper and lower half of a circle respectively while internal variables, that are assumed not to be of interest to the user, are collected in the center of the circle. This achieved by a helper object, the layout emitter, that is initiated with the number of internal, measured and input variables and then calculates the step sizes in the x and y directions that will achieve the circular shape. When we then iterate over each of the variables to get their corresponding descriptive part, the layout emitter is passed as an argument, so that it can be queried for the variables graphical x and y position. This i done in a very naive way, the layout emitter has counters for each of the variable types and then, each time it is queried, it increments the current counter value together with the previously calculated step sizes to generate one x,y coordinate that is returned to the querying variable. 
%\subsubsection{Additional information added}

\section{Interfacing with the tool}
Since there are several separate phases in the tool, and each of the phases might later be extended with additional options and necessary parameters, an XML-file is used to pass information to the tool. By using XML, that is a well known, structured, format for representing data there is not only the benefit of making the inputfiles easy accessible to other developers and software, but also it elmininates the need to develop and maintain the code for parsing a tool specific format. With XML existing modules for parsing and object representation of the XML files can be used. And in the tool, an instance of the inputfile can be passed along to each of the phases. Where each phase then may just extract necessary and optional parameters needed in that particular phase. \\\\Following is an example of the input file to the tool, containing all the necessary parameters.
\lstset{language=XML}
\begin{lstlisting}
<?xml version="1.0" ?> 
<root>
        <filepath>C:\Users\Public\Documents\QuadTankPack.mo</filepath>
        <model>QuadTankPack.QuadTank</model>
        <mpattern>_pmv;_fooBar;x2</mpattern>
        <outputpath>C:\ProMoVis\output.xml</outputpath>
        <pmvoutputpath>C:\ProMoVis\QuadTank.pmv</pmvoutputpath>
</root>
\end{lstlisting}
The filepath and model nodes are the path to the original Modelica source file and the full model name, including packagename respectively. The node, mpattern, contains a regular expression that the tool will try to match to the ending of the variable names. E.g. if the tool encounters the variables foo\_pmv, foo\_foobar, foox2 or x2 it will indicate that those variables should become measured variables in the ProMoVis representation.


\section{DAE vs ODE}
Readers familiar with Modelica and the JModelica environment might be accustomed to working with the ODE-representation of systems. The reason that the tool sticks with the DAE, even though the extraction of SFGs from an ODE is less complex, is due to the fact that when using the ODE we loose causality whenever a state depends on an algebraic variable. For a more thorough discussion of this see Appendix \ref{appB}.


